const { z } = require('zod');

const requestSchema = z.object({
  originalUrl: z.string(),
  method: z.string(),
});
const routerSchema = z.object({
  stack: z.array()
})

module.exports = {
  buildError(request, router, routeNesting = 1) {
    try {
      requestSchema.parse(request);
      routerSchema.parse(router);
      z.number().int().positive().parse(routeNesting);
    } catch (zodErr) {
      const error = new Error(zodErr.message, { cause: zodErr.message });
      error.status = 400;
      return error;
    }

    const { originalUrl, method } = request;
    const { stack } = router;
    if (method === 'OPTIONS') return null;

    const attemptedUrl = originalUrl
      .match('[^?]*')[0] // grabs everything up to but NOT including the first '?'
      .replace(/\/$/, '') // gets rid of trailing '/'
      .toLowerCase();

    const pathToThisRouterRegex = '[^/]*/'
      .repeat(routeNesting)
      .concat('[^(/|?)]*');
    const pathToThisRouter = originalUrl.match(pathToThisRouterRegex);
    // grabs everything up to but NOT including '/' or '?'
    // after the first (routeNesting) number of '/'

    const possibleMethods = stack.reduce((possMeth, curr) => {
      if (!curr.route) return possMeth;
      const { path, methods } = curr.route;
      const fullPath = (pathToThisRouter + path)
        .replace(/(\/|\*)$/, '')
        .toLowerCase();
      if (fullPath === attemptedUrl.toLowerCase())
        Object.keys(methods).forEach((method) => possMeth.push(method));
      /* pathToThisRouter is generated by grabbing the first section of a route.
       * For example for route /example/route it will be /example.
       * If the path to this route is /nested/example/route then you must
       * update the middleware that calls this so that it grabs /nested/example
       * instead of just grabbing /nested.
       */
      return possMeth;
    }, []);
    if (!possibleMethods.length) {
      const cause = `Could not find the appropriate endpoint for ${attemptedUrl} in ${pathToThisRouter}`;
      const error = new Error(cause, { cause });
      error.status = 404;
      return error;
    } else {
      let cause = `You attempted a ${method} request to ${attemptedUrl} try `;
      for (let ind = 0; ind < possibleMethods.length; ind++) {
        const lastMethodInd = possibleMethods.length - 1;
        const method = possibleMethods[ind];
        if (ind === lastMethodInd) cause += `${method.toUpperCase()}.`;
        else cause += `${method.toUpperCase()} or `;
      }
      const error = new Error(cause, { cause });
      error.status = 405;
      console.log(cause, 'CAUSE')
      return error;
    }
  },

  buildAllErrors(request, ...routes) {
    let error;
    for (const currRoute of routes) {
      if (Object.keys(currRoute).length === 2 && 'nestLevel' in currRoute)
        error = buildError(request, currRoute.route, currRoute.nestLevel)
      else error = buildError(request, currRoute);

      if (err === null || error.status === 405 || error.status === 400) return error;
    }
    return error;
  }
}
